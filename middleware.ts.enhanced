import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { jwtVerify } from "jose";

// Define Pro-only routes
const PRO_ONLY_ROUTES = [
  "/audit",
  "/audits", 
  "/reality-audit",
  "/api/reality-audit",
  "/api/audit",
];

// Public routes that don't require any auth
const PUBLIC_ROUTES = [
  "/",
  "/login",
  "/signup",
  "/pricing",
  "/about",
  "/api/auth",
  "/api/stripe/webhook", // Stripe webhooks must be public
];

// Matcher config to specify which paths middleware runs on
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon files and other static assets
     */
    '/((?!_next/static|_next/image|favicon|.*\.ico|.*\.png|.*\.svg|.*\.webmanifest).*)',
  ],
};

// Helper to check if route requires Pro subscription
function isProOnlyRoute(pathname: string): boolean {
  return PRO_ONLY_ROUTES.some(route => pathname.startsWith(route));
}

// Helper to check if route is public
function isPublicRoute(pathname: string): boolean {
  return PUBLIC_ROUTES.some(route => pathname.startsWith(route));
}

// Helper to get user ID from JWT token
async function getUserIdFromToken(token: string): Promise<string | null> {
  try {
    // For Firebase Auth tokens, we need to decode without verification in middleware
    // (Firebase Admin SDK not available in Edge runtime)
    const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());
    return payload.sub || payload.user_id || null;
  } catch {
    return null;
  }
}

export async function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;

  // Always allow public routes
  if (isPublicRoute(pathname)) {
    return NextResponse.next();
  }

  // Get auth token from cookie or header
  const authToken = 
    req.cookies.get("auth-token")?.value || 
    req.headers.get("authorization")?.replace("Bearer ", "");

  // No token = redirect to login
  if (!authToken) {
    return NextResponse.redirect(new URL("/login", req.url));
  }

  // For Pro-only routes, check subscription status
  if (isProOnlyRoute(pathname)) {
    try {
      const userId = await getUserIdFromToken(authToken);
      
      if (!userId) {
        return NextResponse.redirect(new URL("/login", req.url));
      }

      // Call our subscription-status API (internal call)
      const baseUrl = req.nextUrl.origin;
      const statusResponse = await fetch(`${baseUrl}/api/subscription-status?uid=${userId}`, {
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });

      if (!statusResponse.ok) {
        console.error("Failed to check subscription status");
        return NextResponse.redirect(new URL("/pricing", req.url));
      }

      const data = await statusResponse.json();

      // If not Pro, redirect to pricing
      if (data.subscription_status !== "pro") {
        console.log(`ðŸš« User ${userId} tried to access Pro route: ${pathname}`);
        return NextResponse.redirect(new URL("/pricing?upgrade=required", req.url));
      }

      // Pro user - allow access
      console.log(`âœ… Pro user ${userId} accessing: ${pathname}`);
    } catch (error) {
      console.error("Middleware error:", error);
      return NextResponse.redirect(new URL("/pricing", req.url));
    }
  }

  // Allow all other authenticated routes
  return NextResponse.next();
}